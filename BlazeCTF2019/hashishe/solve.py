#Full credit goes to my team mate Crustulum

def egcd(a, b):
    if a == 0:
        return (b, 0, 1)
    else:
        g, y, x = egcd(b % a, a)
        return (g, x - (b // a) * y, y)

def modinv(a, m): #ax % m = 1
    g, x, y = egcd(a, m)
    if g != 1:
        raise Exception('modular inverse does not exist')
    else:
        return x % m

m = 1952805748

p = 28088345631829169912123283453952480197706332893264740410146998572679117489156145575588375992724908318410388827689907
g = 1313772902403042702145633530706134028016998981629281265856968948599108187346044293966059832252758672647776448222988
y = 15026155021119351074255268189325642747960530368674338866062255079051031997244713749796180248271122376380390963987

flag_c1 = 18665621637449387586216245716862912705506689793194710102229834167816108331427117546234085312505782463363021634555685
flag_c2 = 12814775527731532447925081568563630841271580370938380016919608410305749853748869999437749961774029490236689236129203

input_c1 = 18665621637449387586216245716862912705506689793194710102229834167816108331427117546234085312505782463363021634555685
input_c2 = 13393048989698060802153025612480926134332332208424669842418418648794216887057738019724984733271874593958294217008958

minv = modinv(m, p)
bk = input_c2*minv
bmink = modinv(bk, p)
flag = flag_c2*bmink % p

print hex(flag)


'''
c1 = g**k % p
i know g**k is divisable by g and i know g
i know g**k - c1 is divisable by p

c1(g**k * x) % p = 1
'''

#print flag_c1 * modinv(flag_c1, flag_c2) % flag_c2
